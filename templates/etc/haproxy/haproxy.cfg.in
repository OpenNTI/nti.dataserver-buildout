global
	log			127.0.0.1 daemon warning
	# let us take as many connections as possible; let backends
	# do their own queuing. We need to specify a value here or
	# we get haproxy default of 2000. Trying to use too many
	# for the system ulimit results in a warning but startup proceeds.
	maxconn		16384 # Total Max Connections. This is dependent on ulimit
	nbproc		${haproxy_workers}

	stats socket ${haproxy_stats_socket} mode 600 level admin
	stats timeout 2m


frontend httpredir ${haproxy_http_addr}:${haproxy_redirect_to_ssl_port}
	mode http
	log global
	timeout client 600
	default_backend ssl_backend

backend ssl_backend
	mode http
	timeout server 30000
	timeout connect 4000
	# Simply send a 302 redirect to the same Host and path and query
	# the client sent in the first place, but with the
	# https protocol. The client will usually do a GET of
	# the new Location.
	# NOTE: If the Host contained a port, even the default of
	# 80, it would be preserved, so we first rewrite the Host
	# to remove any port
	reqirep ^Host:\ (.*):[0-9]* Host:\ \1
	redirect scheme https


frontend all
	mode http
	log global
	timeout client 86400000
	# Listen for HTTP connections on this port. Give it
	# an ID so it can be tested for.
	# TODO: In multi-tier environments, it might make sense and be
	# more efficient to have this use the accept-proxy option?
	bind ${haproxy_http_addr}:${haproxy_http_port} id ${haproxy_http_port} ${haproxy_http_accept_proxy}
	# Listen on the stunnel socket for incoming SSL in proxy mode
	# We give it a specific id so that we can match in an ACL
	# (We can't match on ssl itself because that's already been handled)
	bind ${stunnel_socket} ${haproxy_stunnel_socket_user} mode 600 id 42 accept-proxy
	default_backend www_backend

	acl is_websocket hdr(Upgrade) -i WebSocket
	acl is_websocket hdr_beg(Host) -i ws

	acl is_dyn path_beg /dataserver
	acl is_dyn path_beg /_ops
	acl is_dyn path_beg /library
	acl is_dyn path_beg /socket.io
	acl is_dyn path_beg /dictionary
	acl is_dyn path_beg ${loginapp_location}resources/css/site.css  #GH added to pass css to DS
	acl is_dyn path_beg ${loginapp_location}resources/strings/site.js #GH added to pass	site strings to DS
	acl is_dyn path_beg ${webapp_location}resources/strings/site.js #CMU added to pass strings files to DS for redirection by site
	acl is_dyn path_beg ${webapp_location}resources/css/site.css

	# Acls for optimizing away having to wait for a several second
	# webapp load if we know we are def. not authed
	acl is_maybe_authed hdr_sub(cookie) nti.auth_tkt # Do we have an auth.tkt? if not we are def. not authed

	# Our stunnel socket is always SSL
	acl is_ssl so_id 42
	# Sometimes in some environments we need additional rules about
	# SSL; for example, it may have been handled by a front-end proxy
	# already. List those here.
	${haproxy_addl_ssl_acls}

	# Define an ACL to block incoming IP addresses
	acl is_blocked_ip src 0.0.0.0
${haproxy_addl_blocked_ip_acls}

	# Block some common attack vectors and private info
	acl is_blocked_name path_end .php .asp .jsp .exe .aspx
	acl is_blocked_name path_end assessment_index.json resources.index
	acl is_blocked_name path_dir .nti_acl indexdir
	block if is_blocked_name

	acl is_host_cors url_sub ?h=

	# Let gunicorn/nginx know if we are dealing with an incoming HTTPS
	# request (This is a default 'secure-header' in gunicorns conf).
	# If we fail do do this, the server cannot correctly generate
	# absolute URLs, and that includes the wss:// URLs used for
	# websockets (and Safari 6 at least, has a problem if the server
	# returns a ws:// URL over SSL; Chrome doesn't care)
	reqidel ^X-FORWARDED-PROTOCOL:.*
	reqadd X-FORWARDED-PROTOCOL:\ ssl if is_ssl

	# Go to the app by default
	#redirect location /down/down.html code 302 if { path_beg /NextThoughtWebApp or path_beg /login }  #THIS IS FOR THE DOWN PAGE ONLY- NOT WORKING YET
	#redirect location /NextThoughtWebApp/index.html code 301 if { path / }
	redirect location /tutorials/index.html code 301 if { path /tutorials }

	# If we might be authenticated, then if we are coming in to the root,
	# try to go to the app instead
	redirect location ${webapp_location} code 302 if is_maybe_authed { path / }

	#use_backend www_backend_up if is_down
	use_backend ip_blocked_backend if is_blocked_ip
	use_backend www_backend if is_host_cors
	use_backend socket_backend if is_websocket
	use_backend socket_backend if is_dyn

backend ip_blocked_backend
	# This backend defines no servers,
	# which means using it results in a 503 Service Unavailable.
	# We use that to map that error to a canned response.
	mode http
	errorfile 503 ${deployment:etc-directory|shell-path}/haproxy/blocked.http


backend www_backend
	mode	http
	balance roundrobin
	# We should already have x-forward-for from
	# stunnel or the front-level haproxy.
	# If we try to set one again,
	# that gets confusing and causes issues by
	# duplicating header names (which is legal, but
	# not everything handles). Because we trust this
	# environment we don't add another header.
	option forwardfor if-none
	#option http-keep-alive # Fast static resource
	# Because we mix and match static content requests with
	# DS requests, true keep-alive might not be possible; the browser
	# could send one request to each type of resource in the same
	# TCP connection
	option http-server-close
	timeout server 30s
	timeout connect 4s
	${nginx_servers}

backend socket_backend
	mode	http
	balance source
	# Recent versions of the server support the PROXY protocol,
	# meaning that X-Forwarded-For is not needed. This lets us
	# not need http-server-close or forwardfor; in theory
	# it might let us use http-keep-alive, if there is any
	# benefit.
	# Unfortunately, because we mix and match static content requests with
	# DS requests, true keep-alive might not be possible; the browser
	# could send one request to each type of resource in the same
	# TCP connection. So we need server-close.
	option http-server-close

	#option forwardfor if-none # This sets X-Forwarded-For
	# If we don't set this, then we lose X-Forwarded-For

	timeout queue 5s
	timeout server 5m
	timeout client 60s
	timeout connect 60s
	# Force websocket connections to move to a different
	# worker every so ofter. This overrides client/server
	# timeout
	timeout tunnel 10m
	${dataserver_servers}
