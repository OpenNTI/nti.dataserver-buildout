global
	log 127.0.0.1 daemon warning
	# let us take as many connections as possible; let backends
	# do their own queuing. We need to specify a value here or
	# we get haproxy default of 2000. Trying to use too many
	# for the system ulimit results in a warning but startup proceeds.
	# Total Max Connections. This is dependent on ulimit. On OS X with a 
	# ulimit of 32767, the maxconn possible is 16366.
	maxconn 16366

	stats socket ${haproxy_stats_socket} mode 600 level admin process 1
	stats timeout 2m

	# SSL Tuning
	tune.ssl.default-dh-param 2048
	tune.ssl.cachesize 20000
	ssl-default-bind-ciphers ${ciphers}
	ssl-default-bind-options no-sslv3 no-tls-tickets

	# Set to use 2 processes. Process 1 is for processing normal traffic. 
	# Processes 2 are for SSL operations.
	nbproc 2

defaults
	maxconn 16366

	timeout queue 5s
	timeout server 15m
	timeout client 15m
	timeout connect 60s
	# Force websocket connections to move to a different
	# worker every so often. This overrides client/server
	# timeout...
	# At least, that's the intent, but it turns out this
	# is an IDLE timeout, so it's much too high to do any
	# good. Should we reconsider? Is this even needed?
	timeout tunnel 15m
	errorfile 408 /dev/null

listen ssl-term
	mode http
	bind-process 2
	${ssl_binds}

	# Let gunicorn/nginx know if we are dealing with an incoming HTTPS request
	# (This is a default 'secure-header' in gunicorns conf)
	# If we fail do do this, the server cannot correctly generate
	# absolute URLs, and that includes the wss:// URLs used for
	# websockets (and Safari 6 at least, has a problem if the server
	# returns a ws:// URL over SSL; Chrome doesn't care)
	reqidel ^X-FORWARDED-PROTOCOL:.*
	reqadd X-FORWARDED-PROTOCOL:\ ssl if { ssl_fc }

	server http unix@${ssl_socket} send-proxy

frontend all
	mode http
	bind-process 1
	log global
	timeout client 86400000
	# Listen for HTTP connections on this port. Give it
	# an ID so it can be tested for.

	# Port for traffic from one backend to another using the proxy protocol
	# As of 3/4/15 only the nodeserver makes use of this
	# In multi-tier environments, not only is it more efficient to
	# have this use the accept-proxy option, but it is required to get proper
	# IP address logs with gunicorn >= 19.x
	bind ${haproxy_addr}:${haproxy_proxy_port} id ${haproxy_proxy_port} accept-proxy

	# Port for admin and dev connections over HTTP
	bind ${haproxy_addr}:${haproxy_http_port} id ${haproxy_http_port}

	# Listen on the socket for incoming SSL in proxy mode
	# We give it a specific id so that we can match in an ACL
	# (We can't match on ssl itself because that's already been handled)
	bind unix@${ssl_socket} user ${ssl_socket_owner} mode 600 id 42 accept-proxy

	default_backend static_backend

	acl robots url_sub -i robots.txt robots-dev.txt
	acl google_verification url_beg /google
	acl is_favicon url_sub -i favicon.ico

	acl is_app path_beg /app
	acl is_app_config path_beg /app/config.js

	acl is_loginapp path_beg /login/

	acl is_mobile path_beg /mobile

	acl is_websocket hdr(Upgrade) -i WebSocket
	acl is_websocket hdr_beg(Host) -i ws

	acl is_content path_beg /content
	acl is_content path_beg /hosted_badge_images

	acl is_dyn path_beg /dataserver
	acl is_dyn path_beg /_ops
	acl is_dyn path_beg /socket.io
	acl is_dyn path_beg /library
	acl is_dyn path_beg /dictionary

	acl is_import_export path_beg /dataserver2/CourseAdmin

	acl is_render path_beg /dataserver2/Library/

	acl is_sync path_beg /dataserver2/@@SyncAllLibraries
	acl is_sync path_beg /dataserver2/SyncAllLibraries

	# Block some common attack vectors and private info
	acl is_blocked_name path_end .php .asp .jsp .exe .aspx
	acl is_blocked_name path_end assessment_index.json resources.index
	acl is_blocked_name path_dir .nti_acl indexdir
	http-request deny if is_blocked_name

	acl is_host_cors url_sub ?h=

	# Make sure we use the dev robots file in dev environments
	reqrep ^([^\ :]*)\ .*/robots.txt\ ([^\ ]*) \1\ /robots-dev.txt\ \2 if robots

	# The plain strings (non-site-specific) is also passed to the DS
	# for language negotiation and a redirect
	#acl is_dyn path_beg /app/resources/strings/strings.js
	acl is_base_strings path_beg /app/resources/strings/strings.js
	redirect location /app/resources/locales/en/LC_MESSAGES/NextThoughtWebApp.js code 302 if is_base_strings

	# Acls for optimizing away having to wait for a several second
	# webapp load if we know we are def. not authed
	acl is_maybe_authed hdr_sub(cookie) nti.auth_tkt # Do we have an auth.tkt? if not we are def. not authed

	# Our stunnel socket is always SSL
	acl is_ssl so_id 42
	# Sometimes in some environments we need additional rules about
	# SSL; for example, it may have been handled by a front-end proxy
	# already. List those here.
	${haproxy_addl_ssl_acls}

	# Define an ACL to block incoming IP addresses
	acl is_blocked_ip src 0.0.0.0
	${haproxy_addl_blocked_ip_acls}

	${haproxy_extra_config}

	${haproxy_extra_redirects}

	# If we might be authenticated, then if we are coming in to the root,
	# try to go to the app instead. This helps preserve old bookmarks
	# as well as streamlining the process.
	redirect location /app/ code 302 if is_maybe_authed { path / } !robots !google_verification !is_favicon

	# use_backend www_backend_up if is_down
	use_backend s3_backend if robots
	use_backend s3_backend if google_verification
	use_backend content_backend if is_content
	use_backend static_backend if is_app_config
	use_backend static_backend if is_favicon
	use_backend static_backend if is_host_cors
	use_backend node_backend if is_app
    use_backend node_backend if is_loginapp
	use_backend node_backend if is_mobile
	use_backend render_backend if is_import_export
	use_backend render_backend if is_render
	use_backend render_backend if is_sync
	use_backend data_backend if is_websocket
	use_backend data_backend if is_dyn

backend s3_backend
	mode http
	balance roundrobin

	reqrep  ^Host:\ .*  Host:\ s3.amazonaws.com
	reqirep  ^([^\ ]*)\ /(.*) \1\ /nextthought-support-pages/\2

	server s3 s3.amazonaws.com:443 ssl verify none

backend ip_blocked_backend
	# This backend defines no servers,
	# which means using it results in a 503 Service Unavailable.
	# We use that to map that error to a canned response.
	mode http
	errorfile 503 ${deployment:etc-directory|shell-path}/haproxy/blocked.http

backend static_backend
	mode	http
	balance roundrobin
	# We expect to be talking PROXY to nginx, so
	# no need to mess with x-forworded-for.

	# Because we mix and match static content requests with
	# DS requests, true keep-alive might not be possible; the browser
	# could send one request to each type of resource in the same
	# TCP connection
	# NOTE: This seems to be fixed in 1.5-dev22
	# option http-server-close
	option prefer-last-server

	${haproxy_backend_port_rewrite}

	timeout server 15m
	timeout connect 4s

	option httpchk GET / HTTP/1.1\r\nHost:\ ${hostname}

	${nginx_servers}

backend content_backend
	mode http
	balance roundrobin
	option prefer-last-server

	timeout server 15m
	timeout connect 4s

	${content_servers}

backend data_backend
	mode	http
	balance source
	# Recent versions of the server support (and require) the PROXY
	# protocol, meaning that X-Forwarded-For is not needed (or even
	# supported anymore). This lets us not need http-server-close or
	# forwardfor; in theory it might let us use http-keep-alive, if
	# there is any benefit.

	# Unfortunately, because we mix and match static content requests with
	# DS requests, true keep-alive might not be possible; the browser
	# could send one request to each type of resource in the same
	# TCP connection. So we need server-close.
	# NOTE: This seems to be fixed in 1.5-dev22
	# option http-server-close
	option prefer-last-server
	# option forwardfor if-none # This sets X-Forwarded-For
	# If we don't set this, then we lose X-Forwarded-For

	option httpchk GET /_ops/ping HTTP/1.1\r\nHost:\ ${hostname}

	${dataserver_servers}

backend render_backend
    mode http
    balance source
    hash-type consistent sdbm avalanche
    # Recent versions of the server support (and require) the PROXY
    # protocol, meaning that X-Forwarded-For is not needed (or even
    # supported anymore). This lets us not need http-server-close or
    # forwardfor; in theory it might let us use http-keep-alive, if
    # there is any benefit.

    # Unfortunately, because we mix and match static content requests with
    # DS requests, true keep-alive might not be possible; the browser
    # could send one request to each type of resource in the same
    # TCP connection. So we need server-close.
    # NOTE: This seems to be fixed in 1.5-dev22
    #option http-server-close
    option prefer-last-server
    # option forwardfor if-none # This sets X-Forwarded-For
    # If we don't set this, then we lose X-Forwarded-For

    option httpchk GET /_ops/ping HTTP/1.1\r\nHost:\ ${hostname}

    ${render_servers}

backend node_backend
	mode http
	option prefer-last-server
	timeout server 15m
	timeout connect 4s

	option httpchk GET /mobile/api/_ops/ping HTTP/1.1\r\nHost:\ ${hostname}

	${nodejs_servers}
