global
	log			127.0.0.1 daemon warning
	maxconn		4096 # Total Max Connections. This is dependent on ulimit
	nbproc		${haproxy_workers}

	stats socket ${haproxy_stats_socket} mode 600 level admin
	stats timeout 2m


frontend httpredir ${haproxy_http_addr}:${haproxy_redirect_to_ssl_port}
	mode http
	log global
	timeout client 600
	default_backend ssl_backend

backend ssl_backend
	mode http
	timeout server 30000
	timeout connect 4000
	# Simply send a 302 redirect to the same Host and path and query
	# the client sent in the first place, but with the
	# https protocol. The client will usually do a GET of
	# the new Location.
	# NOTE: If the Host contained a port, even the default of
	# 80, it would be preserved, so we first rewrite the Host
	# to remove any port
	reqirep ^Host:\ (.*):[0-9]* Host:\ \1
	redirect scheme https


frontend all
	mode http
	log global
	timeout client 86400000
	# Listen for HTTP connections on this port. Give it
	# an ID so it can be tested for.
	# TODO: In multi-tier environments, it might make sense and be
	# more efficient to have this use the accept-proxy option?
	bind ${haproxy_http_addr}:${haproxy_http_port} id ${haproxy_http_port}
	# Listen on the stunnel socket for incoming SSL in proxy mode
	# We give it a specific id so that we can match in an ACL
	# (We can't match on ssl itself because that's already been handled)
	bind ${stunnel_socket} ${haproxy_stunnel_socket_user} mode 600 id 42 accept-proxy
	default_backend www_backend

	acl is_websocket hdr(Upgrade) -i WebSocket
	acl is_websocket hdr_beg(Host) -i ws

	acl is_dyn path_beg /dataserver
	acl is_dyn path_beg /_ops
	acl is_dyn path_beg /library
	acl is_dyn path_beg /socket.io
	acl is_dyn path_beg /dictionary
	acl is_dyn path_beg /login/resources/css/site.css  #GH added to pass css to DS
	acl is_dyn path_beg /login/resources/strings/site.js #GH added to pass	site strings to DS
	acl is_dyn path_beg /resources/strings/site.js #CMU added to pass strings files to DS for redirection by site
	acl is_dyn path_beg /resources/css/site.css

	# Acls for the mess of a landing page
	acl is_landing_site path_beg /landing/site.html #This needs to be proxyied to the ds
	acl landing path_beg /landing #Is this a landing related request
	acl landing_cookie hdr_sub(cookie) nti.landing_site_name #Do we have the cookies that tells us what site landing to user

	# Acls for optimizing away having to wait for a several second
	# webapp load if we know we are def. not authed
	acl is_maybe_authed hdr_sub(cookie) nti.auth_tkt # Do we have an auth.tkt? if not we are def. not authed

	# Our stunnel socket is always SSL
	acl is_ssl so_id 42
	# Sometimes in some environments we need additional rules about
	# SSL; for example, it may have been handled by a front-end proxy
	# already. List those here.
	${haproxy_addl_ssl_acls}

	# Block some common attack vectors and private info
	acl is_blocked_name path_end .php .asp .jsp .exe .aspx
	acl is_blocked_name path_dir .nti_acl indexdir
	block if is_blocked_name

	acl is_host_cors url_sub ?h=

	# Let gunicorn/nginx know if we are dealing with an incoming HTTPS
	# request (This is a default 'secure-header' in gunicorns conf).
	# If we fail do do this, the server cannot correctly generate
	# absolute URLs, and that includes the wss:// URLs used for
	# websockets (and Safari 6 at least, has a problem if the server
	# returns a ws:// URL over SSL; Chrome doesn't care)
	reqidel ^X-FORWARDED-PROTOCOL:.*
	reqadd X-FORWARDED-PROTOCOL:\ ssl if is_ssl

	# Go to the app by default
	#redirect location /down/down.html code 302 if { path_beg /NextThoughtWebApp or path_beg /login }  #THIS IS FOR THE DOWN PAGE ONLY- NOT WORKING YET
	#redirect location /NextThoughtWebApp/index.html code 301 if { path / }
	redirect location /tutorials/index.html code 301 if { path /tutorials }
	#redirect location /login/index.html?return=%2FNextThoughtWebApp%2Findex.html&host=https%3A%2F%2Falpha.nextthought.com code 301 if { path / }

	# If we are requesting a landing resource with no landing cookie
	# and it isn't the special site send to login
${login_redirect_enabled}	redirect location /login/ code 302 if landing !landing_cookie !is_landing_site

	# If we are trying to get to the webapp and we know there is no
	# way we can be authenticated dont waste time going to the app
	redirect location /landing/site.html code 302 if !is_maybe_authed { path / }

	#use_backend www_backend_up if is_down
	use_backend www_backend if is_host_cors
	use_backend socket_backend if is_websocket
	use_backend socket_backend if is_dyn
	#send the special landing site to the dataserver
	use_backend socket_backend if is_landing_site



backend www_backend
	mode		http
	balance roundrobin
	# We should already have x-forward-for from
	# stunnel or the front-level haproxy.
	# If we try to set one again,
	# that gets confusing and causes issues by
	# duplicating header names (which is legal, but
	# not everything handles). Because we trust this
	# environment we don't add another header.
	option forwardfor if-none
	option http-keep-alive # Fast static resource
	timeout server 30000
	timeout connect 4000
	${nginx_servers}

backend socket_backend
	mode		http
	balance roundrobin
	option forwardfor if-none # This sets X-Forwarded-For
	# If we don't set this, then we lose X-Forwarded-For
	option http-server-close

	# TODO: Convert httpchk into tcp-check for speed?
	option httpchk GET /_ops/ping

	timeout queue 5000
	timeout server 86400000
	timeout connect 86400000
	${dataserver_servers}
