	sendfile		on;
	tcp_nopush		on;
	directio		1m;
	${aio}

	keepalive_timeout  65;
	keepalive_disable none;

	gzip  on;
	gzip_static on;
	gzip_types text/css text/javascript application/xml application/x-javascript application/javascript text/xml ;
	gzip_comp_level 9;
	gzip_proxied any;
	gzip_vary on;
	gzip_http_version 1.0;

	#need to map the landing cookie.  Can we get this in the location somehow?
	map $http_cookie $site_landing_name {
		default ${default_landing_site_name};
		~nti.landing_site_name=(?<mc>[^\;]+) $mc;
	}

	open_file_cache max=1000; # inactive=600s;
	open_file_cache_errors on;

	server {
		listen ${nginx_http_port};
		# For single machine or developers,
		# listening on a unix socket is convenient
		# for use with haproxy
		listen unix:${deployment:run-directory/nginx.sock};
		root   ${global_content_directory|shell-path};
		server_name	 ${global_host_name};
		proxy_http_version 1.1;
		etag on;
		if_modified_since before;
		lingering_close on;

		set_real_ip_from 192.168.0.0/24;
		set_real_ip_from 10.50.0.0/24;
		set_real_ip_from 10.50.8.0/24;
		set_real_ip_from 127.0.0.1;
		set_real_ip_from unix:;
		real_ip_recursive on;
		real_ip_header X-Forwarded-For;

		location /this/should/not/exist.html {
			error_page 404 =503 /maintenance/index.html;
		}

		location / {
			index  index.html index.htm;
			root ${loginapp_path/src/main/WebApp|shell-path}/;
			expires +1h;
			add_header Cache-Control proxy-revalidate;
			# Is there a maintenance page? If so, go there. Did we get a
			# landing cookie that maps to a file on disk? if so, go there;
			# do the same for the server name. Finally, if nothing matches,
			# go to login.
			try_files /maintenance/index.html
					  /landing/$site_landing_name$uri
					  /landing/$host$uri
					  /landing/$server_name$uri
					  /landing/$site_landing_name$uri/index.html
					  /landing/$host$uri/index.html
					  /landing/$server_name$uri/index.html
					  @login;
		}

		location = /maintenance/index.html {
			expires 30s;
		}

		location = /loginsuccess {
			# On a successful login, the login app will redirect
			# here by default (see defaults.js). We then
			# redirect to the app; this keeps the coupling minimal
			port_in_redirect off;
			rewrite ^.*$ ${webapp_location} redirect;
		}

		location @login {
			# Redirect to the default port (haproxy), not our local
			# port, which isn't reachable.
			port_in_redirect off;

			rewrite ^.*$ /login/ redirect;
		}

		location /dataserver {
			# We don't proxy to the DS; haproxy in front
			# of us should do that.
			return 404;
		}

		location ${webapp_location} {
			alias ${webapp_path/src/main/|shell-path}/;
			# a header so that we can do a head request and try to
			# bust the cached redirect... see login app.
			add_header X-NTI-WebApp true;
		}

		location ${webapp_location}config.js {
			alias ${webapp_config_file};
		}

		location ${global_content_location} {
			alias ${global_content_directory/.|shell-path}/;
		}

		location ${global_content_location}welcome/ {
			alias ${webapp_path/src/main/content/welcome/|shell-path}/;
		}

		location /purchasables/ { # JAM: Not sure what this is
			alias /var/www/html/purchasables/;
		}

		location ${loginapp_location} {
			alias ${loginapp_path/src/main/WebApp/|shell-path}/;

			expires +1h;
			add_header Cache-Control proxy-revalidate;

		}

 		# JAM: The locations beginning with /NextThoughtWebApp/ are for
		# BWC (old bookmarks) only right now.
		location /NextThoughtWebApp/ {
			alias ${webapp_path/src/main/|shell-path}/;
		}

		location /NextThoughtWebApp/config.js {
			alias ${webapp_config_file};
		}

		# JAM: Likewise for /landing
		location /landing {
			# Send them to the root
			rewrite ^/landing$ / redirect;
			rewrite ^/landing/(.*)$ /$1 redirect;
			# Redirect to the default port (haproxy), not our local
			# port, which isn't reachable.
			port_in_redirect off;
		}

		# deny access to .htaccess files, if Apache's document root
		# concurs with nginx's one
		#
		location ~ /\.ht {
			deny  all;
		}

	}
