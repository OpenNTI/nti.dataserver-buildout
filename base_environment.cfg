[buildout]
extends =
		sites.cfg
		products.cfg
		deployment.cfg
		buildout.cfg

parts +=
	  passwords
	  directories
	  zcml
	  redis
	  redis-conf
	  pserve-conf
	  gunicorn-conf
	  library-conf
	  webapp-conf
	  clean-pyc

[passwords]
recipe = nti.recipes.passwords
# Real environments will specify the
# file = argument, pointing to a .cast5
# file stored in source control. All the
# settings in that file that have the same name
# as this section will be added to this section
# and available for use in other parts.
sql_passwd =
smtp_passwd =
aws_secret_access_key =

[environment]
# The environment part defines some settings
# that are specific to the environment and
# often used in more than one other part.
# TODO: This part is very large and is included
# by multiple other sections. For the file templates,
# its use can cause too many other things to change.
# split this up into the actual related groups
sql_user = ec2user
sql_host = localhost
# A space separated list of host:port servers
# TODO: Move this to the memcached_conf and pull from there;
# it isn't directly applicable there though so you might
# get warnings about unused variables
cache_servers = localhost:11211
smtp_server =
smtp_from = automated-emails@nextthought.com
smtp_username =
smtp_use_tls = true
# port 25 is often blocked by ISPs, use one of the alternates, 465 or 587
smtp_port = 587
# This content is loaded and made available for library
# navigation in all sites. It is also served as the
# document root by nginx currently. Can be defined as a path
# relative to the buildout directory and will be normalized
# (mostly for developers)
global_content_directory = ${buildout:directory}/../DataserverGlobalLibrary
# The prefix under which nginx will make the
# content directory available. This is also
# given to the server so it can make the right
# urls.
global_content_location = /content/
# This hosted back images directory. Can be defined as a path
# relative to the buildout directory and will be normalized
# (mostly for developers)
hosted_badge_images_directory = ${buildout:directory}/../hosted_badge_images
# The prefix under which nginx will make the
# hosted badge images available.
hosted_badge_images_location = /hosted_badge_images/
# The primary DNS name of the environment
global_host_name = localhost
# the port the dataserver should listen on
dataserver_http_port = 8081
# the ports that nginx should listen on
nginx_http_port = 8080
# the ports that nodejs should listen on
nodejs_http_port = 8083
nginx_proxy_port = 8085
nginx_user = nginx
nginx_workers = 9
# The location the webapp will be checked out to. Can be defined as a
# path relative to the buildout directory and will be normalized
webapp_path = ${buildout:directory}/../NextThoughtWebApp
# The location the login app will be checked out to. Can be defined as
# a path relative to the buildout directory and will be normalized
loginapp_path = ${buildout:directory}/../NextThoughtLoginApp
# The location of the mobile webapp

# The prefix that the webapp occupies in the
# URL space. This MUST end with a trailing slash,
# and MUST not be empty
webapp_location = /app/

# The prefix that the login app occupies in the
# URL space. This MUST end with a trailing slash.
loginapp_location = /login/

# The main port haproxy listens on
haproxy_http_port = 8082
haproxy_http_addr = 127.0.0.1
haproxy_workers = 1
# If haproxy gets a connection here, it will
# redirect to the ssl port. Usually 80.
haproxy_redirect_to_ssl_port = 7999

stunnel_socket = ${deployment:run-directory}/ssl-frontend.sock
stunnel_pid_file = ${deployment:run-directory}/stunnel.pid
# NOTE: The cert file name SHOULD match the default
# name; otherwise the process that builds stunnel
# prompts to create a default cert (prior to 5.0)
stunnel_cert_file = ${deployment:etc-directory}/stunnel/stunnel.pem
stunnel_https_address = 0.0.0.0
stunnel_https_port = 8443
stunnel_foreground = yes
stunnel_socket_owner =
haproxy_stunnel_socket_user =

# See the passwords recipe
sql_passwd = ${passwords:sql_passwd}
smtp_passwd = ${passwords:smtp_passwd}

[boto]
# Boto configuration
# Note that when using Amazon SES, this is NEVER
# the same thing as the SMTP username; the SMTP
# username is entirely different
aws_access_key_id =
aws_secret_access_key = ${passwords:aws_secret_access_key}

[zcml]
# XXX: This section is officially deprecated now;
# it should only be used to add features, not packages
# or pyramid---those are handled with z3c.autoinclude
# You can use the <= syntax to pull in desired features

recipe = nti.recipes.zcml
deployment = deployment

package_zcml =

package_location = package-includes

package_features =
			in-buildout
			forums

pyramid_zcml =

pyramid_location = pyramid-includes
pyramid_file = pyramid
pyramid_features = ${:package_features}

[redis]
recipe = hexagonit.recipe.cmmi
url = http://download.redis.io/releases/redis-2.8.17.tar.gz
keep-compile-dir = true
configure-command = true
make-options =
			 PREFIX=${buildout:directory}
			 INSTALL_BIN=${deployment:bin-directory}

[redis-conf]
recipe = z3c.recipe.filetemplate
extends = environment
source-directory = templates
dest-directory = ${deployment:root-directory}
force-overwrite = true
files = redis.conf main.ini

# Redis settings
# Disable tcp usage by default
port = 0
# Saving.
# JAM: The default save settings (900/1 300/10, 60/10000) are
# probably insufficient for development purposes (few keys change, and
# restarts are rapid and often kill the redis server). Therefore, our
# default development configuration saves much *too* frequently for
# realworld use: every 30 seconds if anything has changed.
save-settings = save 30 1
redis-path = ${deployment:bin-directory}/redis-server

redis_client_url = file://${deployment:run-directory}/redis.sock

# memcache settings
memcached_servers = ${environment:cache_servers}
# The command line to include in supervisor
redis-supervisor = 10 redis ${:redis-path} [${deployment:etc-directory}/redis.conf]

[pserve-conf]
recipe = z3c.recipe.filetemplate
# The recipe doesn't take into account
# variables from other sections used in the template
# when determining if it needs to update. Using
# extends seems to fix this
extends = environment
source-directory = templates
force-overwrite = true
dest-directory = ${deployment:root-directory}
files = pserve.ini

### Settings for the dataserver
debug_error_in_html = false
dataserver_log_level = DEBUG
# This is unused?
deploy_root = ${environment:global_content_directory}
mail_queue_path = ${deployment:mail-directory}
email_error_subject_prefix = Error
email_error_from = automated.emails@nextthought.com
email_error_to = server-errors@nextthought.com
email_default_from = no-reply@nextthought.com
cookie_secret = ${environment:global_host_name}
session_cookie_secret = ${environment:global_host_name}

###
# Extra pyramid configuration
pyramid_includes =

###
## Purchase email confirmations
# For site policies that load the 'send additional purchase confirmation subscriber',
# these addressess will get the emails.
# NOTE: This falls down if multiple sites in the same environment
# need to get different purchase confirmations.
# A whitespace separated list
###
purchase_additional_confirmation_addresses =

## Use secure settings by default; development
# environments need to specifically opt-out of this.
secure_cookies = 1

[gunicorn-conf]
recipe = z3c.recipe.filetemplate
extends = environment
source-directory = templates
force-overwrite = true
dest-directory = ${deployment:root-directory}

files = gunicorn.conf.py

http-port = ${environment:dataserver_http_port}
# A unix socket can be used by nginx for its 'upstream'
# more efficiently than even loopback
unix-socket = ${deployment:run-directory}/dataserver.sock

# For deployment, preloading is awesome. But for those hacking on the
# python code, it interfers with running a debugger in the sub-process
# since it doesn't exec(). This is a python literal
preload_app = True
# Auto-calculate by default
workers =
timeout = 1800
# Leave blank for trusted environments
forwarded_allow_ips =

# The maximum number of requests a worker will process before
# restarting. Any value greater than zero will limit the number of
# requests a work will process before automatically restarting. This
# is a simple method to help limit the damage of memory leaks. If this
# is set to zero (the default) then the automatic worker restarts are
# disabled.
max_requests = 0

# The maximum number of simultaneous clients. This setting only
# affects the Eventlet and Gevent worker types.
worker_connections = 1000


[library-conf]
recipe = z3c.recipe.filetemplate
extends = environment
source-directory = templates
force-overwrite = true
dest-directory = ${deployment:root-directory}
files = library.zcml

library-type = filesystemLibrary
library-args =
			 directory="${environment:global_content_directory}"
			 prefix="${environment:global_content_location}"

[nginx-conf]
recipe = z3c.recipe.filetemplate
source-directory = templates
dest-directory = ${deployment:root-directory}
# the main conf file is already installed
# as part of building nginx, we must overwrite it
force-overwrite = true
files = nginx.conf dataserver.conf

# Whether nginx should daemonize. Set it to
# off if you will be controlling it with
# supervisor, on if system will control it
nginx_daemon = off
aio = aio on;
# The location of the config file
# on disk for the webapp.
webapp_config_file = ${deployment:root-directory}/etc/webapp/config.js

# The default landing site name. Set this in environments
# that only hae one landing site so that deep links
# work even without the site cookie.
default_landing_site_name = $host

# Copy these things in from the environment; eventually
# they should move directly here; the extends keyword is a
# bad idea if there are many unrelated settings
webapp_path = ${environment:webapp_path}
webapp_location = ${environment:webapp_location}
loginapp_path = ${environment:loginapp_path}
loginapp_location = ${environment:loginapp_location}
mobileweb_path = ${environment:mobileweb_path}
nginx_http_port = ${environment:nginx_http_port}
dataserver_http_port = ${environment:dataserver_http_port}
nodejs_http_port = ${environment:nodejs_http_port}
global_host_name = ${environment:global_host_name}
global_content_directory = ${environment:global_content_directory}
global_content_location = ${environment:global_content_location}
hosted_badge_images_directory = ${environment:hosted_badge_images_directory}
hosted_badge_images_location = ${environment:hosted_badge_images_location}
nginx_user = ${environment:nginx_user}
nginx_workers = ${environment:nginx_workers}

nginx_proxy_port = ${environment:nginx_proxy_port}

# How many files to keep in the open cache. This should be
# at least 60K in production (smaller in dev where ulimits
# are usually not set up)
nginx_max_open_files = 60000

[nginx-conf:macosx]
# AIO is not even a directive on osx
aio =


[haproxy-conf]
recipe = z3c.recipe.filetemplate
extends = environment
source-directory = templates
dest-directory = ${deployment:root-directory}
# the main conf file is already installed
# as part of building nginx, we must overwrite it
force-overwrite = true
files = haproxy.cfg blocked.http
interpreted-options = haproxy_addl_blocked_ip_acls

# The trailing comment matters; see developer_zeo_conf
haproxy_backend_port_rewrite = #

# If we have additional incoming hosts that
# define SSL traffic, such as a front-end proxy,
# list them here. Each line is of the form
# acl is_ssl RULE. Be careful with this.
# To match all incoming traffic, assuming that
# ssl is always the case, you can use something like this:
#       acl is_ssl so_id ${environment:haproxy_http_port}
haproxy_addl_ssl_acls =

# Read from easily-updated files the IP addressess
# we want to block. See http://www.ip2location.com/free/visitor-blocker
# Haproxy has a 2K limit on the length of a line, which
# a few of these exceed if we try to list them all at once, so we break
# them up
haproxy_addl_blocked_ip_acls =
    ''.join([
		''.join(['\tacl is_blocked_ip src ' + x for x in open('templates/etc/haproxy/'+the_file, 'rU').readlines()])
		for the_file in ('burma-myanmar-cidr.txt',
					 	 'cuba-cidr.txt',
  						 'iran-cidr.txt',
						 'lebanon-cidr.txt',
						 'northkorea-cidr.txt',
						 'sudan-cidr.txt',
						 'syria-cidr.txt')])

# Set this to 'accept-proxy' if a frontend will
# also be haproxy; then it should use send-proxy in its
# server line and this will obviate the need for server-close
# to get x-forwarded-for
haproxy_http_accept_proxy =

# HAproxy stats on a unix socket. See
# http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#9.2
haproxy_stats_socket = ${deployment:run-directory}/haproxy.sock
# TODO: There are recipes that enumerate other sections; we
# probably want to use those here to avoid having to
# manually list out all server ips again. Alternatively,
# our own meta recipe.

# Sadly, the server section doesn't support a unix socket,
# even though the ambiguious documentation suggests it might
# (as-of 1.5-dev22)
nginx_servers =
			  server nginx 127.0.0.1:${nginx-conf:nginx_proxy_port} weight 1 send-proxy

dataserver_servers =
				   server dataserver 127.0.0.1:${environment:dataserver_http_port} observe layer7 weight 1 send-proxy

nodejs_servers =
				   server nodejs 127.0.0.1:${environment:nodejs_http_port} observe layer7 weight 1 send-proxy

[webapp-conf]
recipe = z3c.recipe.filetemplate
source-directory = templates
dest-directory = ${deployment:root-directory}
files = config.js 999-NextThoughtWebApp-translations.zcml 999-nti.app.i18n.zcml

# The list of features and whether they are on or
# not. The last one should not be followed by a comma.
# Probably best to replace this entirely per-environment
# than extend it.
features =
 		 "mutable-forums":true,
		 "fancy-scroll":true,
		 "notepad":true,
		 "v3matching":false,
		 "transcript-follow-video":true,
		 "video-settings":true

#We can optionally specificy a kaltura uiconf id which is
#nice for testing features outside of prod (blank by default
#which means the one hardcoded in the app)
kalturaUIID =

# The location to redirect to when
# the user is not logged in
unauth_location = ${environment:loginapp_location}

# prevent usernames from displaying
# in the app as plain text
obscure_usernames = false

#Open external PDF Content Card links in a new tab
external_pdf_new_window = false

# Whether mobile Safari is allowed
allow_mobile_safari = false

# A string hash value for CloudFront
# CORS caching issues. Environment specific.
cors_salt =  ${environment:global_host_name}

# The master switch to remove user profile
# support. Set to true in COPPA environments
disable_profiles = false

# Controls the presence of a global onerror
# handler to trap uncaught errors during load.
# on by default but useful to turn off in dev environments
enable_global_onerror = true

# Controls the console output mode. (On or Off)
enable_logging = true


[stunnel-conf]
recipe = z3c.recipe.filetemplate
extends = environment
source-directory = templates
dest-directory = ${deployment:root-directory}
force-overwrite = true
files = stunnel.conf

[stunnel-cert]
# For creating the stunnel cert.
# In this case, we simply copy a default,
# but for production uses, use openssl.
# This should come *before* stunnel itself is built
# to avoid interactive prompts
recipe = collective.recipe.cmd
on_install = true
cmds = cp ${buildout:directory}/certs/stunnel_default.pem ${environment:stunnel_cert_file}

[eggs]
# Here we list the common application requirements
# that are used in all environments, but no sites
eggs +=
	nti.app.assessment
	nti.contenttypes.courses
	nti.wsgi.cors
	nti.app.client_preferences
	nti.app.pyramid_zope
	nti.app.hypatia
	nti.hypatia
	nti.app.store
	nti.store
	nti.metadata

# Let scripts know where they should reach the dataserver
# It's important to only put the Boto keys in the environment
# if they are defined, as they take highest precedence
initialization +=
			   os.environ['DATASERVER_BUILDOUT_PORT'] = "${environment:dataserver_http_port}"
			   os.environ['HOSTED_BADGE_IMAGES_DIR'] = "${environment:hosted_badge_images_directory}"
			   if "${boto:aws_secret_access_key}": os.environ['AWS_SECRET_ACCESS_KEY'] = "${boto:aws_secret_access_key}"
			   if "${boto:aws_access_key_id}": os.environ['AWS_ACCESS_KEY_ID'] = "${boto:aws_access_key_id}"

[crashmail_macro]
program =
supervisor=crashmail_${:program} PROCESS_STATE_EXITED ${deployment:bin-directory}/crashmail [-p ${:program} -m ${pserve-conf:email_error_to} -o ${pserve-conf:email_error_subject_prefix} ]

[crashmail_pserve]
<= crashmail_macro
program = pserve

[fatalmail]
# NOTE: You may need to batch process_state_email_monitor.py
# if you get an error "expected STARTTLS first" to add 's.starttls()'
# NOTE: If some of these things aren't configured, but
# you don't override this, expect fatalmail to not get started
# and expect error messages from supervisor
supervisor=fatalmail PROCESS_STATE,TICK_60 ${deployment:bin-directory}/fatalmailbatch [-t ${pserve-conf:email_error_to} -f ${pserve-conf:email_error_from} -s ${pserve-conf:email_error_subject_prefix} -H ${environment:smtp_server}:${environment:smtp_port} -u ${environment:smtp_username} -p ${passwords:smtp_passwd}]

[supervisor]
recipe = collective.recipe.supervisor
plugins =
		superlance
		mr.laforge
# mr.laforge allows us to say 'supervisorctl kill HUP nginx' https://pypi.python.org/pypi/mr.laforge/0.6
# superlance is where the crash listeners come from http://superlance.readthedocs.org/en/latest/
d_plugins = mr.laforge
ctl_plugins = mr.laforge
rpcplugins = laforge mr.laforge.rpcinterface:make_laforge_rpcinterface
ctlplugins = laforge mr.laforge.controllerplugin:make_laforge_controllerplugin


supervisord-conf = ${deployment:etc-directory}/supervisord.conf
http-socket = unix
file = ${deployment:run-directory}/supervisord.sock
serverurl = unix:///${:file}
childlogdir = ${deployment:log-directory}
logfile = ${deployment:log-directory}/supervisord.log
pidfile = ${deployment:run-directory}/supervisord.pid
loglevel = info
supervisord-environment =
						DATASERVER_DIR=${deployment:root-directory},PYTHONHASHSEED=random

pserve-ini = ${deployment:etc-directory}/pserve.ini

eventlisteners =
			   ${crashmail_pserve:supervisor}
			   ${fatalmail:supervisor}

programs =
		 999 pserve ${deployment:root-directory}/bin/nti_pserve [${:pserve-ini}]
		 ${redis-conf:redis-supervisor}
		 99 metadata ${deployment:bin-directory}/nti_metadata_processor [-v -m 15 -x 30 -l 100]


# This option lists the programs that must be running
# for the server to be considered running. In general,
# anything that uses the server code should be listed here.
# entries are comma separated
pserve_group_programs = pserve

groups =
	   999 server ${:pserve_group_programs}

[clean-pyc]
# Having .pyc or .pyo files around in develop eggs
# is dangerous if the source file was deleted. It
# can lead to things apparently working (e.g., imports,
# ZODB objects) that really won't on a fresh checkout.
recipe = collective.recipe.cmd
on_install = true
on_update = true
cmds = find ${buildout:sources-dir} -name "*.py[co]" -delete


[qp-cron]
# This recipe installs cronjobs for the current user
# In this case, to run the queue processor.
# NOTE: The command winds up as the subject of an email
# from cron if there's an error. If we're using plain qp,
# it has the password. Should we write a shell script and run that?
# Alternativly, qp makes mention of some .ini file
# When using plain qp and SMTP, use port 587, port 25 may be throttled.
#
# Using nti_qp talks directly to boto, so the boto keys must be correctly
# configured
recipe = z3c.recipe.usercrontab
times = */5 * * * *
command = ${deployment:bin-directory}/nti_qp ${deployment:mail-directory}

[memcache-mon-cron]
recipe = z3c.recipe.usercrontab
times = */7 * * * *
command = conn=`echo stats |socat tcp-connect:${environment:cache_servers} stdio | grep curr_connections | awk '{print $3}' | python -c 'import sys; print sys.stdin.readline().strip()'`; if [ "$conn" -gt "17000" ]; then echo "WARNING: $conn memcache connections"; fi

[libevent]
# Needed by memcached
recipe = hexagonit.recipe.cmmi
url = http://sourceforge.net/projects/levent/files/libevent/libevent-2.0/libevent-2.0.21-stable.tar.gz

[memcached]
recipe = hexagonit.recipe.cmmi
url = http://memcached.googlecode.com/files/memcached-1.4.15.tar.gz
# See https://code.google.com/p/memcached/issues/detail?id=285
# It passes -Werror but also unused arguments, which
# fails on clang; this is mostly an OS X problem, but doesn't
# hurt to fix everywhere
patches =
		${buildout:directory}/patches/memcached/patch-configure.diff
configure-options =
				  --with-libevent=${libevent:location}
				  --disable-dependency-tracking
				  --enable-64bit
				  --disable-docs

[memcached-conf]
memcached-port = 11211
memcached-bin = ${memcached:location}/bin/memcached
# Environment buildouts can add options like -m to
# extra-opts
extra-opts =
memcached-opts = -p ${:memcached-port} -U ${:memcached-port} -D / ${:extra-opts}

memcached-supervisor = 1 memcached ${memcached-conf:memcached-bin} [${memcached-conf:memcached-opts}]
